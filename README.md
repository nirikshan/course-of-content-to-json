# course-of-content-to-json

This is simple program where I have converted course of content to json format for example 

```bash
Chapter 1: Introduction .................................................................................................. 2
Section 1.1: Hello World ................................................................................................................................................. 2
Section 1.2: Original "Hello, World!" in K&R C .............................................................................................................. 4

Chapter 2: Comments ................................................................................................................................................. 6
Section 2.1: Commenting using the preprocessor ...................................................................................................... 6
Section 2.2: /* */ delimited comments ........................................................................................................................ 6
Section 2.3: // delimited comments ............................................................................................................................ 7
Section 2.4: Possible pitfall due to trigraphs .............................................................................................................. 7

Chapter 3: Data Types ............................................................................................................................................... 9
Section 3.1: Interpreting Declarations .......................................................................................................................... 9
Section 3.2: Fixed Width Integer Types (since C99) ................................................................................................. 11
Section 3.3: Integer types and constants .................................................................................................................. 11
Section 3.4: Floating Point Constants ........................................................................................................................ 12
Section 3.5: String Literals .......................................................................................................................................... 13

Chapter 4: Operators ............................................................................................................................................... 14
Section 4.1: Relational Operators ............................................................................................................................... 14
Section 4.2: Conditional Operator/Ternary Operator ............................................................................................. 15
Section 4.3: Bitwise Operators ................................................................................................................................... 16
Section 4.4: Short circuit behavior of logical operators .......................................................................................... 18
Section 4.5: Comma Operator ................................................................................................................................... 19
Section 4.6: Arithmetic Operators .............................................................................................................................. 19
Section 4.7: Access Operators ................................................................................................................................... 22
Section 4.8: sizeof Operator ....................................................................................................................................... 24
Section 4.9: Cast Operator ......................................................................................................................................... 24
Section 4.10: Function Call Operator ......................................................................................................................... 24
Section 4.11: Increment / Decrement ......................................................................................................................... 25
Section 4.12: Assignment Operators .......................................................................................................................... 25
Section 4.13: Logical Operators .................................................................................................................................. 26
Section 4.14: Pointer Arithmetic .................................................................................................................................. 27
Section 4.15: _Alignof .................................................................................................................................................. 28

Chapter 5: Boolean .................................................................................................................................................... 30
Section 5.1: Using stdbool.h ........................................................................................................................................ 30
Section 5.2: Using #deﬁne .......................................................................................................................................... 30
Section 5.3: Using the Intrinsic (built-in) Type _Bool ............................................................................................... 31
Section 5.4: Integers and pointers in Boolean expressions .................................................................................... 31
Section 5.5: Deﬁning a bool type using typedef ...................................................................................................... 32

Chapter 6: Strings ....................................................................................................................................................... 33
Section 6.1: Tokenisation: strtok(), strtok_r() and strtok_s() .................................................................................. 33
Section 6.2: String literals ........................................................................................................................................... 35
Section 6.3: Calculate the Length: strlen() ................................................................................................................ 36
Section 6.4: Basic introduction to strings .................................................................................................................. 37
Section 6.5: Copying strings ....................................................................................................................................... 37
Section 6.6: Iterating Over the Characters in a String ............................................................................................. 40
Section 6.7: Creating Arrays of Strings ..................................................................................................................... 41
Section 6.8: Convert Strings to Number: atoi(), atof() (dangerous, don't use them) ........................................... 41
Section 6.9: string formatted data read/write ......................................................................................................... 42

Section 6.10: Find ﬁrst/last occurrence of a speciﬁc character: strchr(), strrchr() ............................................... 43
Section 6.11: Copy and Concatenation: strcpy(), strcat() ........................................................................................ 44
Section 6.12: Comparsion: strcmp(), strncmp(), strcasecmp(), strncasecmp() .................................................... 45
Section 6.13: Safely convert Strings to Number: strtoX functions .......................................................................... 47
Section 6.14: strspn and strcspn ................................................................................................................................. 48

Chapter 7: Literals for numbers, characters and strings ...................................................................... 50
Section 7.1: Floating point literals ............................................................................................................................... 50
Section 7.2: String literals ........................................................................................................................................... 50
Section 7.3: Character literals .................................................................................................................................... 50
Section 7.4: Integer literals ......................................................................................................................................... 51

Chapter 8: Compound Literals ............................................................................................................................. 53
Section 8.1: Deﬁnition/Initialisation of Compound Literals ...................................................................................... 53

Chapter 9: Bit-ﬁelds .................................................................................................................................................. 55
Section 9.1: Bit-ﬁelds .................................................................................................................................................... 55
Section 9.2: Using bit-ﬁelds as small integers .......................................................................................................... 56
Section 9.3: Bit-ﬁeld alignment .................................................................................................................................. 56
Section 9.4: Don'ts for bit-ﬁelds ................................................................................................................................. 57
Section 9.5: When are bit-ﬁelds useful? .................................................................................................................... 58

Chapter 10: Arrays ...................................................................................................................................................... 60
Section 10.1: Declaring and initializing an array ....................................................................................................... 60
Section 10.2: Iterating through an array eciently and row-major order ............................................................ 61
Section 10.3: Array length ........................................................................................................................................... 62
Section 10.4: Passing multidimensional arrays to a function ................................................................................. 63
Section 10.5: Multi-dimensional arrays ...................................................................................................................... 64
Section 10.6: Deﬁne array and access array element ............................................................................................. 67
Section 10.7: Clearing array contents (zeroing) ....................................................................................................... 67
Section 10.8: Setting values in arrays ........................................................................................................................ 68
Section 10.9: Allocate and zero-initialize an array with user deﬁned size ............................................................. 68
Section 10.10: Iterating through an array using pointers ........................................................................................ 69

Chapter 11: Linked lists ............................................................................................................................................. 71
Section 11.1: A doubly linked list .................................................................................................................................. 71
Section 11.2: Reversing a linked list ............................................................................................................................ 73
Section 11.3: Inserting a node at the nth position ..................................................................................................... 75
Section 11.4: Inserting a node at the beginning of a singly linked list .................................................................... 76

Chapter 12: Enumerations ...................................................................................................................................... 79
Section 12.1: Simple Enumeration ............................................................................................................................... 79
Section 12.2: enumeration constant without typename .......................................................................................... 80
Section 12.3: Enumeration with duplicate value ....................................................................................................... 80
Section 12.4: Typedef enum ....................................................................................................................................... 81

Chapter 13: Structs ..................................................................................................................................................... 83
Section 13.1: Flexible Array Members ......................................................................................................................... 83
Section 13.2: Typedef Structs ..................................................................................................................................... 85
Section 13.3: Pointers to structs .................................................................................................................................. 86
Section 13.4: Passing structs to functions ................................................................................................................. 88
Section 13.5: Object-based programming using structs ......................................................................................... 89
Section 13.6: Simple data structures .......................................................................................................................... 91

Chapter 14: Standard Math ................................................................................................................................... 93
Section 14.1: Power functions - pow(), powf(), powl() .............................................................................................. 93
Section 14.2: Double precision ﬂoating-point remainder: fmod() .......................................................................... 94

Section 14.3: Single precision and long double precision ﬂoating-point remainder: fmodf(), fmodl() ............... 94

Chapter 15: Iteration Statements/Loops: for, while, do-while ............................................................ 96
Section 15.1: For loop ................................................................................................................................................... 96
Section 15.2: Loop Unrolling and Du's Device ........................................................................................................ 96
Section 15.3: While loop ............................................................................................................................................... 97
Section 15.4: Do-While loop ........................................................................................................................................ 97
Section 15.5: Structure and ﬂow of control in a for loop ......................................................................................... 98
Section 15.6: Inﬁnite Loops .......................................................................................................................................... 99

Chapter 16: Selection Statements .................................................................................................................... 100
Section 16.1: if () Statements ..................................................................................................................................... 100
Section 16.2: Nested if() else VS if() else Ladder .................................................................................................. 100
Section 16.3: switch () Statements ........................................................................................................................... 102
Section 16.4: if ()  else statements and syntax ..................................................................................................... 104
Section 16.5: if() else Ladder Chaining two or more if ()  else statements ....................................................... 104

Chapter 17: Initialization ........................................................................................................................................ 105
Section 17.1: Initialization of Variables in C .............................................................................................................. 105
Section 17.2: Using designated initializers ............................................................................................................... 106
Section 17.3: Initializing structures and arrays of structures ................................................................................ 108

Chapter 18: Declaration vs Deﬁnition ............................................................................................................ 110
Section 18.1: Understanding Declaration and Deﬁnition ....................................................................................... 110

Chapter 19: Command-line arguments ......................................................................................................... 111
Section 19.1: Print the arguments to a program and convert to integer values ................................................. 111
Section 19.2: Printing the command line arguments ............................................................................................. 111
Section 19.3: Using GNU getopt tools ...................................................................................................................... 112

Chapter 20: Files and I/O streams .................................................................................................................. 115
Section 20.1: Open and write to ﬁle ......................................................................................................................... 115
Section 20.2: Run process ........................................................................................................................................ 116
Section 20.3: fprintf ................................................................................................................................................... 116
Section 20.4: Get lines from a ﬁle using getline() .................................................................................................. 116
Section 20.5: fscanf() ................................................................................................................................................ 120
Section 20.6: Read lines from a ﬁle ......................................................................................................................... 121
Section 20.7: Open and write to a binary ﬁle ......................................................................................................... 122

Chapter 21: Formatted Input/Output ............................................................................................................. 124
Section 21.1: Conversion Speciﬁers for printing ...................................................................................................... 124
Section 21.2: The printf() Function ........................................................................................................................... 125
Section 21.3: Printing format ﬂags ........................................................................................................................... 125
Section 21.4: Printing the Value of a Pointer to an Object .................................................................................... 126
Section 21.5: Printing the Dierence of the Values of two Pointers to an Object ............................................... 127
Section 21.6: Length modiﬁers ................................................................................................................................. 128

Chapter 22: Pointers ................................................................................................................................................ 129
Section 22.1: Introduction ......................................................................................................................................... 129
Section 22.2: Common errors .................................................................................................................................. 131
Section 22.3: Dereferencing a Pointer .................................................................................................................... 134
Section 22.4: Dereferencing a Pointer to a struct .................................................................................................. 134
Section 22.5: Const Pointers ..................................................................................................................................... 135
Section 22.6: Function pointers ................................................................................................................................ 138
Section 22.7: Polymorphic behaviour with void pointers ...................................................................................... 139
Section 22.8: Address-of Operator ( & ) ................................................................................................................. 140
Section 22.9: Initializing Pointers ............................................................................................................................. 140

Section 22.10: Pointer to Pointer .............................................................................................................................. 141
Section 22.11: void* pointers as arguments and return values to standard functions ....................................... 141
Section 22.12: Same Asterisk, Dierent Meanings ................................................................................................. 142

Chapter 23: Sequence points .............................................................................................................................. 144
Section 23.1: Unsequenced expressions .................................................................................................................. 144
Section 23.2: Sequenced expressions ..................................................................................................................... 144
Section 23.3: Indeterminately sequenced expressions ......................................................................................... 145

Chapter 24: Function Pointers ........................................................................................................................... 146
Section 24.1: Introduction .......................................................................................................................................... 146
Section 24.2: Returning Function Pointers from a Function ................................................................................. 146
Section 24.3: Best Practices ..................................................................................................................................... 147
Section 24.4: Assigning a Function Pointer ............................................................................................................. 149
Section 24.5: Mnemonic for writing function pointers ........................................................................................... 149
Section 24.6: Basics ................................................................................................................................................... 150

Chapter 25: Function Parameters .................................................................................................................... 152
Section 25.1: Parameters are passed by value ...................................................................................................... 152
Section 25.2: Passing in Arrays to Functions .......................................................................................................... 152
Section 25.3: Order of function parameter execution ........................................................................................... 153
Section 25.4: Using pointer parameters to return multiple values ...................................................................... 153
Section 25.5: Example of function returning struct containing values with error codes ................................... 154

Chapter 26: Pass 2D-arrays to functions ..................................................................................................... 156
Section 26.1: Pass a 2D-array to a function ........................................................................................................... 156
Section 26.2: Using ﬂat arrays as 2D arrays .......................................................................................................... 162

Chapter 27: Error handling .................................................................................................................................. 163
Section 27.1: errno ..................................................................................................................................................... 163
Section 27.2: strerror ................................................................................................................................................. 163
Section 27.3: perror ................................................................................................................................................... 163

Chapter 28: Undeﬁned behavior ...................................................................................................................... 165
Section 28.1: Dereferencing a pointer to variable beyond its lifetime ................................................................. 165
Section 28.2: Copying overlapping memory .......................................................................................................... 165
Section 28.3: Signed integer overﬂow ..................................................................................................................... 166
Section 28.4: Use of an uninitialized variable ......................................................................................................... 167
Section 28.5: Data race ............................................................................................................................................ 168
Section 28.6: Read value of pointer that was freed .............................................................................................. 169
Section 28.7: Using incorrect format speciﬁer in printf ......................................................................................... 170
Section 28.8: Modify string literal ............................................................................................................................ 170
Section 28.9: Passing a null pointer to printf %s conversion ................................................................................ 170
Section 28.10: Modifying any object more than once between two sequence points ....................................... 171
Section 28.11: Freeing memory twice ...................................................................................................................... 172
Section 28.12: Bit shifting using negative counts or beyond the width of the type ............................................ 172
Section 28.13: Returning from a function that's declared with `_Noreturn` or `noreturn` function speciﬁer
............................................................................................................................................................................. 173
Section 28.14: Accessing memory beyond allocated chunk ................................................................................. 174
Section 28.15: Modifying a const variable using a pointer .................................................................................... 174
Section 28.16: Reading an uninitialized object that is not backed by memory .................................................. 175
Section 28.17: Addition or subtraction of pointer not properly bounded ............................................................ 175
Section 28.18: Dereferencing a null pointer ............................................................................................................ 175
Section 28.19: Using ush on an input stream ...................................................................................................... 176
Section 28.20: Inconsistent linkage of identiﬁers ................................................................................................... 176
Section 28.21: Missing return statement in value returning function ................................................................... 177

Section 28.22: Division by zero ................................................................................................................................ 177
Section 28.23: Conversion between pointer types produces incorrectly aligned result .................................... 178
Section 28.24: Modifying the string returned by getenv, strerror, and setlocale functions .............................. 179

Chapter 29: Random Number Generation ................................................................................................... 180
Section 29.1: Basic Random Number Generation .................................................................................................. 180
Section 29.2: Permuted Congruential Generator ................................................................................................... 180
Section 29.3: Xorshift Generation ............................................................................................................................ 181
Section 29.4: Restrict generation to a given range ............................................................................................... 182

Chapter 30: Preprocessor and Macros .......................................................................................................... 183
Section 30.1: Header Include Guards ....................................................................................................................... 183
Section 30.2: #if 0 to block out code sections ........................................................................................................ 186
Section 30.3: Function-like macros .......................................................................................................................... 187
Section 30.4: Source ﬁle inclusion ............................................................................................................................ 188
Section 30.5: Conditional inclusion and conditional function signature modiﬁcation ....................................... 188
Section 30.6: __cplusplus for using C externals in C++ code compiled with C++ - name mangling ............... 190
Section 30.7: Token pasting ..................................................................................................................................... 191
Section 30.8: Predeﬁned Macros ............................................................................................................................. 192
Section 30.9: Variadic arguments macro ............................................................................................................... 193
Section 30.10: Macro Replacement ......................................................................................................................... 194
Section 30.11: Error directive ..................................................................................................................................... 195
Section 30.12: FOREACH implementation ............................................................................................................... 196

Chapter 31: Signal handling ................................................................................................................................. 199
Section 31.1: Signal Handling with “signal()” ............................................................................................................ 199

Chapter 32: Variable arguments ...................................................................................................................... 201
Section 32.1: Using an explicit count argument to determine the length of the va_list .................................... 201
Section 32.2: Using terminator values to determine the end of va_list .............................................................. 202
Section 32.3: Implementing functions with a `printf()`-like interface ................................................................... 202
Section 32.4: Using a format string ......................................................................................................................... 205

Chapter 33: Assertion ............................................................................................................................................. 207
Section 33.1: Simple Assertion .................................................................................................................................. 207
Section 33.2: Static Assertion ................................................................................................................................... 207
Section 33.3: Assert Error Messages ....................................................................................................................... 208
Section 33.4: Assertion of Unreachable Code ........................................................................................................ 209
Section 33.5: Precondition and Postcondition ........................................................................................................ 209

Chapter 34: Generic selection ............................................................................................................................ 211
Section 34.1: Check whether a variable is of a certain qualiﬁed type .................................................................. 211
Section 34.2: Generic selection based on multiple arguments ............................................................................. 211
Section 34.3: Type-generic printing macro ............................................................................................................ 213

Chapter 35: X-macros ............................................................................................................................................ 214
Section 35.1: Trivial use of X-macros for printfs ..................................................................................................... 214
Section 35.2: Extension: Give the X macro as an argument ................................................................................. 214
Section 35.3: Enum Value and Identiﬁer ................................................................................................................. 215
Section 35.4: Code generation ................................................................................................................................. 215

Chapter 36: Aliasing and eective type ....................................................................................................... 217
Section 36.1: Eective type ....................................................................................................................................... 217
Section 36.2: restrict qualiﬁcation ............................................................................................................................ 217
Section 36.3: Changing bytes ................................................................................................................................... 218
Section 36.4: Character types cannot be accessed through non-character types ........................................... 219
Section 36.5: Violating the strict aliasing rules ....................................................................................................... 220

Chapter 37: Compilation ....................................................................................................................................... 221
Section 37.1: The Compiler ........................................................................................................................................ 221
Section 37.2: File Types ............................................................................................................................................ 222
Section 37.3: The Linker ............................................................................................................................................ 222
Section 37.4: The Preprocessor ............................................................................................................................... 224
Section 37.5: The Translation Phases ...................................................................................................................... 225

Chapter 38: Inline assembly ................................................................................................................................ 227
Section 38.1: gcc Inline assembly in macros ........................................................................................................... 227
Section 38.2: gcc Basic asm support ...................................................................................................................... 227
Section 38.3: gcc Extended asm support ................................................................................................................ 228

Chapter 39: Identiﬁer Scope ............................................................................................................................... 229
Section 39.1: Function Prototype Scope .................................................................................................................. 229
Section 39.2: Block Scope ......................................................................................................................................... 230
Section 39.3: File Scope ............................................................................................................................................ 230
Section 39.4: Function scope .................................................................................................................................... 231

Chapter 40: Implicit and Explicit Conversions ........................................................................................... 232
Section 40.1: Integer Conversions in Function Calls ............................................................................................... 232
Section 40.2: Pointer Conversions in Function Calls .............................................................................................. 233

Chapter 41: Type Qualiﬁers ................................................................................................................................ 235
Section 41.1: Volatile variables .................................................................................................................................. 235
Section 41.2: Unmodiﬁable (const) variables ......................................................................................................... 236

Chapter 42: Typedef .............................................................................................................................................. 237
Section 42.1: Typedef for Structures and Unions ................................................................................................... 237
Section 42.2: Typedef for Function Pointers .......................................................................................................... 238
Section 42.3: Simple Uses of Typedef ..................................................................................................................... 239

Chapter 43: Storage Classes .............................................................................................................................. 241
Section 43.1: auto ....................................................................................................................................................... 241
Section 43.2: register ................................................................................................................................................ 241
Section 43.3: static ..................................................................................................................................................... 242
Section 43.4: typedef ................................................................................................................................................ 243
Section 43.5: extern ................................................................................................................................................... 243
Section 43.6: _Thread_local .................................................................................................................................... 244

Chapter 44: Declarations .................................................................................................................................... 246
Section 44.1: Calling a function from another C ﬁle ............................................................................................... 246
Section 44.2: Using a Global Variable ..................................................................................................................... 247
Section 44.3: Introduction ......................................................................................................................................... 247
Section 44.4: Typedef ............................................................................................................................................... 250
Section 44.5: Using Global Constants ..................................................................................................................... 250
Section 44.6: Using the right-left or spiral rule to decipher C declaration .......................................................... 252

Chapter 45: Structure Padding and Packing ............................................................................................. 256
Section 45.1: Packing structures .............................................................................................................................. 256
Section 45.2: Structure padding .............................................................................................................................. 257

Chapter 46: Memory management ................................................................................................................ 258
Section 46.1: Allocating Memory .............................................................................................................................. 258
Section 46.2: Freeing Memory ................................................................................................................................. 259
Section 46.3: Reallocating Memory ......................................................................................................................... 261
Section 46.4: realloc(ptr, 0) is not equivalent to free(ptr) ..................................................................................... 262
Section 46.5: Multidimensional arrays of variable size ......................................................................................... 262
Section 46.6: alloca: allocate memory on stack .................................................................................................... 263

Section 46.7: User-deﬁned memory management ............................................................................................... 264

Chapter 47: Implementation-deﬁned behaviour ..................................................................................... 266
Section 47.1: Right shift of a negative integer ........................................................................................................ 266
Section 47.2: Assigning an out-of-range value to an integer ............................................................................... 266
Section 47.3: Allocating zero bytes .......................................................................................................................... 266
Section 47.4: Representation of signed integers ................................................................................................... 266

Chapter 48: Atomics ............................................................................................................................................... 267
Section 48.1: atomics and operators ....................................................................................................................... 267

Chapter 49: Jump Statements .......................................................................................................................... 268
Section 49.1: Using return ......................................................................................................................................... 268
Section 49.2: Using goto to jump out of nested loops .......................................................................................... 268
Section 49.3: Using break and continue ................................................................................................................. 269

Chapter 50: Create and include header ﬁles ............................................................................................. 271
Section 50.1: Introduction ......................................................................................................................................... 271
Section 50.2: Self-containment ................................................................................................................................ 271
Section 50.3: Minimality ............................................................................................................................................ 273
Section 50.4: Notation and Miscellany .................................................................................................................... 273
Section 50.5: Idempotence ....................................................................................................................................... 275
Section 50.6: Include What You Use (IWYU) ........................................................................................................... 275

Chapter 51: <ctype.h> — character classiﬁcation & conversion ....................................................... 277
Section 51.1: Introduction .......................................................................................................................................... 277
Section 51.2: Classifying characters read from a stream ..................................................................................... 278
Section 51.3: Classifying characters from a string ................................................................................................. 279

Chapter 52: Side Eects ....................................................................................................................................... 280
Section 52.1: Pre/Post Increment/Decrement operators ..................................................................................... 280

Chapter 53: Multi-Character Character Sequence .................................................................................. 282
Section 53.1: Trigraphs .............................................................................................................................................. 282
Section 53.2: Digraphs .............................................................................................................................................. 282

Chapter 54: Constraints ........................................................................................................................................ 284
Section 54.1: Duplicate variable names in the same scope .................................................................................. 284
Section 54.2: Unary arithmetic operators .............................................................................................................. 284

Chapter 55: Inlining ................................................................................................................................................. 285
Section 55.1: Inlining functions used in more than one source ﬁle ....................................................................... 285

Chapter 56: Unions ................................................................................................................................................... 287
Section 56.1: Using unions to reinterpret values .................................................................................................... 287
Section 56.2: Writing to one union member and reading from another ............................................................. 287
Section 56.3: Dierence between struct and union ............................................................................................... 288

Chapter 57: Threads (native) ............................................................................................................................. 289
Section 57.1: Inititialization by one thread ............................................................................................................... 289
Section 57.2: Start several threads .......................................................................................................................... 289

Chapter 58: Multithreading ................................................................................................................................. 291
Section 58.1: C11 Threads simple example .............................................................................................................. 291

Chapter 59: Interprocess Communication (IPC) ........................................................................................ 292
Section 59.1: Semaphores ......................................................................................................................................... 292

Chapter 60: Testing frameworks ..................................................................................................................... 297
Section 60.1: Unity Test Framework ........................................................................................................................ 297
Section 60.2: CMocka ................................................................................................................................................ 297
Section 60.3: CppUTest ............................................................................................................................................. 298

Chapter 61: Valgrind ................................................................................................................................................ 300
Section 61.1: Bytes lost -- Forgetting to free ........................................................................................................... 300
Section 61.2: Most common errors encountered while using Valgrind ................................................................ 300
Section 61.3: Running Valgrind ................................................................................................................................. 301
Section 61.4: Adding ﬂags ......................................................................................................................................... 301

Chapter 62: Common C programming idioms and developer practices ..................................... 302
Section 62.1: Comparing literal and variable .......................................................................................................... 302
Section 62.2: Do not leave the parameter list of a function blank — use void ................................................... 302

Chapter 63: Common pitfalls .............................................................................................................................. 305
Section 63.1: Mixing signed and unsigned integers in arithmetic operations ...................................................... 305
Section 63.2: Macros are simple string replacements .......................................................................................... 305
Section 63.3: Forgetting to copy the return value of realloc into a temporary .................................................. 307
Section 63.4: Forgetting to allocate one extra byte for \0 ................................................................................... 308
Section 63.5: Misunderstanding array decay ......................................................................................................... 308
Section 63.6: Forgetting to free memory (memory leaks) ................................................................................... 310
Section 63.7: Copying too much .............................................................................................................................. 311
Section 63.8: Mistakenly writing = instead of == when comparing ....................................................................... 312
Section 63.9: Newline character is not consumed in typical scanf() call ............................................................ 313
Section 63.10: Adding a semicolon to a #deﬁne .................................................................................................... 314
Section 63.11: Incautious use of semicolons ............................................................................................................ 314
Section 63.12: Undeﬁned reference errors when linking ....................................................................................... 315
Section 63.13: Checking logical expression against 'true' ...................................................................................... 317
Section 63.14: Doing extra scaling in pointer arithmetic ....................................................................................... 318
Section 63.15: Multi-line comments cannot be nested ........................................................................................... 319
Section 63.16: Ignoring return values of library functions ..................................................................................... 321
Section 63.17: Comparing ﬂoating point numbers ................................................................................................. 321
Section 63.18: Floating point literals are of type double by default ..................................................................... 323
Section 63.19: Using character constants instead of string literals, and vice versa ........................................... 323
Section 63.20: Recursive function — missing out the base condition .................................................................. 324
Section 63.21: Overstepping array boundaries ...................................................................................................... 325
Section 63.22: Passing unadjacent arrays to functions expecting "real" multidimensional arrays ................. 326


```

```json

[{
    "TARGET_POINT": 0,
    "title": "Introduction",
    "page": "1",
    "subs": [{
        "title": "Hello World",
        "page": "1.1"
    }, {
        "title": "Original \"Hello, World!\" in K&R C",
        "page": "1.2"
    }]
}, {
    "TARGET_POINT": 1,
    "title": "Comments",
    "page": "2",
    "subs": [{
        "title": "Commenting using the preprocessor",
        "page": "2.1"
    }, {
        "title": "/* */ delimited comments",
        "page": "2.2"
    }, {
        "title": "// delimited comments",
        "page": "2.3"
    }, {
        "title": "Possible pitfall due to trigraphs",
        "page": "2.4"
    }]
}, {
    "TARGET_POINT": 2,
    "title": "Data Types",
    "page": "3",
    "subs": [{
        "title": "Interpreting Declarations",
        "page": "3.1"
    }, {
        "title": "Fixed Width Integer Types (since C99)",
        "page": "3.2"
    }, {
        "title": "Integer types and constants",
        "page": "3.3"
    }, {
        "title": "Floating Point Constants",
        "page": "3.4"
    }, {
        "title": "String Literals",
        "page": "3.5"
    }]
}, {
    "TARGET_POINT": 3,
    "title": "Operators",
    "page": "4",
    "subs": [{
        "title": "Relational Operators",
        "page": "4.1"
    }, {
        "title": "Conditional Operator/Ternary Operator",
        "page": "4.2"
    }, {
        "title": "Bitwise Operators",
        "page": "4.3"
    }, {
        "title": "Short circuit behavior of logical operators",
        "page": "4.4"
    }, {
        "title": "Comma Operator",
        "page": "4.5"
    }, {
        "title": "Arithmetic Operators",
        "page": "4.6"
    }, {
        "title": "Access Operators",
        "page": "4.7"
    }, {
        "title": "sizeof Operator",
        "page": "4.8"
    }, {
        "title": "Cast Operator",
        "page": "4.9"
    }, {
        "title": "Function Call Operator",
        "page": "4.10"
    }, {
        "title": "Increment / Decrement",
        "page": "4.11"
    }, {
        "title": "Assignment Operators",
        "page": "4.12"
    }, {
        "title": "Logical Operators",
        "page": "4.13"
    }, {
        "title": "Pointer Arithmetic",
        "page": "4.14"
    }, {
        "title": "_Alignof",
        "page": "4.15"
    }]
}, {
    "TARGET_POINT": 4,
    "title": "Boolean",
    "page": "5",
    "subs": [{
        "title": "Using #deﬁne",
        "page": "5.1"
    }, {
        "title": "Using #deﬁne",
        "page": "5.2"
    }, {
        "title": "Using the Intrinsic (built-in) Type _Bool",
        "page": "5.3"
    }, {
        "title": "Integers and pointers in Boolean expressions",
        "page": "5.4"
    }, {
        "title": "Deﬁning a bool type using typedef",
        "page": "5.5"
    }]
}, {
    "TARGET_POINT": 5,
    "title": "Strings",
    "page": "6",
    "subs": [{
        "title": "strtok(), strtok_r() and strtok_s()",
        "page": "6.1"
    }, {
        "title": "String literals",
        "page": "6.2"
    }, {
        "title": "strlen()",
        "page": "6.3"
    }, {
        "title": "Basic introduction to strings",
        "page": "6.4"
    }, {
        "title": "Copying strings",
        "page": "6.5"
    }, {
        "title": "Iterating Over the Characters in a String",
        "page": "6.6"
    }, {
        "title": "Creating Arrays of Strings",
        "page": "6.7"
    }, {
        "title": "atoi(), atof() (dangerous, don't use them)",
        "page": "6.8"
    }, {
        "title": "string formatted data read/write",
        "page": "6.9"
    }, {
        "title": "strchr(), strrchr()",
        "page": "6.10"
    }, {
        "title": "strcpy(), strcat()",
        "page": "6.11"
    }, {
        "title": "strcmp(), strncmp(), strcasecmp(), strncasecmp()",
        "page": "6.12"
    }, {
        "title": "strtoX functions",
        "page": "6.13"
    }, {
        "title": "strspn and strcspn",
        "page": "6.14"
    }]
}, {
    "TARGET_POINT": 6,
    "title": "Literals for numbers, characters and strings",
    "page": "7",
    "subs": [{
        "title": "Floating point literals",
        "page": "7.1"
    }, {
        "title": "String literals",
        "page": "7.2"
    }, {
        "title": "Character literals",
        "page": "7.3"
    }, {
        "title": "Integer literals",
        "page": "7.4"
    }]
}, {
    "TARGET_POINT": 7,
    "title": "Compound Literals",
    "page": "8",
    "subs": [{
        "title": "Deﬁnition/Initialisation of Compound Literals",
        "page": "8.1"
    }]
}, {
    "TARGET_POINT": 8,
    "title": "Bit-ﬁelds",
    "page": "9",
    "subs": [{
        "title": "Bit-ﬁelds",
        "page": "9.1"
    }, {
        "title": "Using bit-ﬁelds as small integers",
        "page": "9.2"
    }, {
        "title": "Bit-ﬁeld alignment",
        "page": "9.3"
    }, {
        "title": "Don'ts for bit-ﬁelds",
        "page": "9.4"
    }, {
        "title": "When are bit-ﬁelds useful?",
        "page": "9.5"
    }]
}, {
    "TARGET_POINT": 9,
    "title": "Arrays",
    "page": "10",
    "subs": [{
        "title": "Declaring and initializing an array",
        "page": "10.1"
    }, {
        "title": "Iterating through an array eciently and row-major order",
        "page": "10.2"
    }, {
        "title": "Array length",
        "page": "10.3"
    }, {
        "title": "Passing multidimensional arrays to a function",
        "page": "10.4"
    }, {
        "title": "Multi-dimensional arrays",
        "page": "10.5"
    }, {
        "title": "Deﬁne array and access array element",
        "page": "10.6"
    }, {
        "title": "Clearing array contents (zeroing)",
        "page": "10.7"
    }, {
        "title": "Setting values in arrays",
        "page": "10.8"
    }, {
        "title": "Allocate and zero-initialize an array with user deﬁned size",
        "page": "10.9"
    }, {
        "title": "Iterating through an array using pointers",
        "page": "10.10"
    }]
}, {
    "TARGET_POINT": 10,
    "title": "Linked lists",
    "page": "11",
    "subs": [{
        "title": "A doubly linked list",
        "page": "11.1"
    }, {
        "title": "Reversing a linked list",
        "page": "11.2"
    }, {
        "title": "Inserting a node at the nth position",
        "page": "11.3"
    }, {
        "title": "Inserting a node at the beginning of a singly linked list",
        "page": "11.4"
    }]
}, {
    "TARGET_POINT": 11,
    "title": "Enumerations",
    "page": "12",
    "subs": [{
        "title": "Simple Enumeration",
        "page": "12.1"
    }, {
        "title": "enumeration constant without typename",
        "page": "12.2"
    }, {
        "title": "Enumeration with duplicate value",
        "page": "12.3"
    }, {
        "title": "Typedef enum",
        "page": "12.4"
    }]
}, {
    "TARGET_POINT": 12,
    "title": "Structs",
    "page": "13",
    "subs": [{
        "title": "Flexible Array Members",
        "page": "13.1"
    }, {
        "title": "Typedef Structs",
        "page": "13.2"
    }, {
        "title": "Pointers to structs",
        "page": "13.3"
    }, {
        "title": "Passing structs to functions",
        "page": "13.4"
    }, {
        "title": "Object-based programming using structs",
        "page": "13.5"
    }, {
        "title": "Simple data structures",
        "page": "13.6"
    }]
}, {
    "TARGET_POINT": 13,
    "title": "Standard Math",
    "page": "14",
    "subs": [{
        "title": "Power functions - pow(), powf(), powl()",
        "page": "14.1"
    }, {
        "title": "fmod()",
        "page": "14.2"
    }, {
        "title": "fmodf(), fmodl()",
        "page": "14.3"
    }]
}, {
    "TARGET_POINT": 14,
    "title": "for, while, do-while",
    "page": "15",
    "subs": [{
        "title": "For loop",
        "page": "15.1"
    }, {
        "title": "Loop Unrolling and Du's Device",
        "page": "15.2"
    }, {
        "title": "While loop",
        "page": "15.3"
    }, {
        "title": "Do-While loop",
        "page": "15.4"
    }, {
        "title": "Structure and ﬂow of control in a for loop",
        "page": "15.5"
    }, {
        "title": "Inﬁnite Loops",
        "page": "15.6"
    }]
}, {
    "TARGET_POINT": 15,
    "title": "Selection Statements",
    "page": "16",
    "subs": [{
        "title": "if () Statements",
        "page": "16.1"
    }, {
        "title": "Nested if() else VS if() else Ladder",
        "page": "16.2"
    }, {
        "title": "switch () Statements",
        "page": "16.3"
    }, {
        "title": "if ()  else statements and syntax",
        "page": "16.4"
    }, {
        "title": "if() else Ladder Chaining two or more if ()  else statements",
        "page": "16.5"
    }]
}, {
    "TARGET_POINT": 16,
    "title": "Initialization",
    "page": "17",
    "subs": [{
        "title": "Initialization of Variables in C",
        "page": "17.1"
    }, {
        "title": "Using designated initializers",
        "page": "17.2"
    }, {
        "title": "Initializing structures and arrays of structures",
        "page": "17.3"
    }]
}, {
    "TARGET_POINT": 17,
    "title": "Declaration vs Deﬁnition",
    "page": "18",
    "subs": [{
        "title": "Understanding Declaration and Deﬁnition",
        "page": "18.1"
    }]
}, {
    "TARGET_POINT": 18,
    "title": "Command-line arguments",
    "page": "19",
    "subs": [{
        "title": "Print the arguments to a program and convert to integer values",
        "page": "19.1"
    }, {
        "title": "Printing the command line arguments",
        "page": "19.2"
    }, {
        "title": "Using GNU getopt tools",
        "page": "19.3"
    }]
}, {
    "TARGET_POINT": 19,
    "title": "Files and I/O streams",
    "page": "20",
    "subs": [{
        "title": "Open and write to ﬁle",
        "page": "20.1"
    }, {
        "title": "Run process",
        "page": "20.2"
    }, {
        "title": "fprintf",
        "page": "20.3"
    }, {
        "title": "Get lines from a ﬁle using getline()",
        "page": "20.4"
    }, {
        "title": "fscanf()",
        "page": "20.5"
    }, {
        "title": "Read lines from a ﬁle",
        "page": "20.6"
    }, {
        "title": "Open and write to a binary ﬁle",
        "page": "20.7"
    }]
}, {
    "TARGET_POINT": 20,
    "title": "Formatted Input/Output",
    "page": "21",
    "subs": [{
        "title": "Conversion Speciﬁers for printing",
        "page": "21.1"
    }, {
        "title": "The printf() Function",
        "page": "21.2"
    }, {
        "title": "Printing format ﬂags",
        "page": "21.3"
    }, {
        "title": "Printing the Value of a Pointer to an Object",
        "page": "21.4"
    }, {
        "title": "Printing the Dierence of the Values of two Pointers to an Object",
        "page": "21.5"
    }, {
        "title": "Length modiﬁers",
        "page": "21.6"
    }]
}, {
    "TARGET_POINT": 21,
    "title": "Pointers",
    "page": "22",
    "subs": [{
        "title": "Introduction",
        "page": "22.1"
    }, {
        "title": "Common errors",
        "page": "22.2"
    }, {
        "title": "Dereferencing a Pointer",
        "page": "22.3"
    }, {
        "title": "Dereferencing a Pointer to a struct",
        "page": "22.4"
    }, {
        "title": "Const Pointers",
        "page": "22.5"
    }, {
        "title": "Function pointers",
        "page": "22.6"
    }, {
        "title": "Polymorphic behaviour with void pointers",
        "page": "22.7"
    }, {
        "title": "Address-of Operator ( & )",
        "page": "22.8"
    }, {
        "title": "Initializing Pointers",
        "page": "22.9"
    }, {
        "title": "Pointer to Pointer",
        "page": "22.10"
    }, {
        "title": "void* pointers as arguments and return values to standard functions",
        "page": "22.11"
    }, {
        "title": "Same Asterisk, Dierent Meanings",
        "page": "22.12"
    }]
}, {
    "TARGET_POINT": 22,
    "title": "Sequence points",
    "page": "23",
    "subs": [{
        "title": "Unsequenced expressions",
        "page": "23.1"
    }, {
        "title": "Sequenced expressions",
        "page": "23.2"
    }, {
        "title": "Indeterminately sequenced expressions",
        "page": "23.3"
    }]
}, {
    "TARGET_POINT": 23,
    "title": "Function Pointers",
    "page": "24",
    "subs": [{
        "title": "Introduction",
        "page": "24.1"
    }, {
        "title": "Returning Function Pointers from a Function",
        "page": "24.2"
    }, {
        "title": "Best Practices",
        "page": "24.3"
    }, {
        "title": "Assigning a Function Pointer",
        "page": "24.4"
    }, {
        "title": "Mnemonic for writing function pointers",
        "page": "24.5"
    }, {
        "title": "Basics",
        "page": "24.6"
    }]
}, {
    "TARGET_POINT": 24,
    "title": "Function Parameters",
    "page": "25",
    "subs": [{
        "title": "Parameters are passed by value",
        "page": "25.1"
    }, {
        "title": "Passing in Arrays to Functions",
        "page": "25.2"
    }, {
        "title": "Order of function parameter execution",
        "page": "25.3"
    }, {
        "title": "Using pointer parameters to return multiple values",
        "page": "25.4"
    }, {
        "title": "Example of function returning struct containing values with error codes",
        "page": "25.5"
    }]
}, {
    "TARGET_POINT": 25,
    "title": "Pass 2D-arrays to functions",
    "page": "26",
    "subs": [{
        "title": "Pass a 2D-array to a function",
        "page": "26.1"
    }, {
        "title": "Using ﬂat arrays as 2D arrays",
        "page": "26.2"
    }]
}, {
    "TARGET_POINT": 26,
    "title": "Error handling",
    "page": "27",
    "subs": [{
        "title": "errno",
        "page": "27.1"
    }, {
        "title": "strerror",
        "page": "27.2"
    }, {
        "title": "perror",
        "page": "27.3"
    }]
}, {
    "TARGET_POINT": 27,
    "title": "Undeﬁned behavior",
    "page": "28",
    "subs": [{
        "title": "Dereferencing a pointer to variable beyond its lifetime",
        "page": "28.1"
    }, {
        "title": "Copying overlapping memory",
        "page": "28.2"
    }, {
        "title": "Signed integer overﬂow",
        "page": "28.3"
    }, {
        "title": "Use of an uninitialized variable",
        "page": "28.4"
    }, {
        "title": "Data race",
        "page": "28.5"
    }, {
        "title": "Read value of pointer that was freed",
        "page": "28.6"
    }, {
        "title": "Using incorrect format speciﬁer in printf",
        "page": "28.7"
    }, {
        "title": "Modify string literal",
        "page": "28.8"
    }, {
        "title": "Passing a null pointer to printf %s conversion",
        "page": "28.9"
    }, {
        "title": "Modifying any object more than once between two sequence points",
        "page": "28.10"
    }, {
        "title": "Freeing memory twice",
        "page": "28.11"
    }, {
        "title": "Bit shifting using negative counts or beyond the width of the type",
        "page": "28.12"
    }, {
        "title": "Returning from a function that's declared with `_Noreturn` or `noreturn` function speciﬁer",
        "page": "28.13"
    }, {
        "title": "Accessing memory beyond allocated chunk",
        "page": "28.14"
    }, {
        "title": "Modifying a const variable using a pointer",
        "page": "28.15"
    }, {
        "title": "Reading an uninitialized object that is not backed by memory",
        "page": "28.16"
    }, {
        "title": "Addition or subtraction of pointer not properly bounded",
        "page": "28.17"
    }, {
        "title": "Dereferencing a null pointer",
        "page": "28.18"
    }, {
        "title": "Using ush on an input stream",
        "page": "28.19"
    }, {
        "title": "Inconsistent linkage of identiﬁers",
        "page": "28.20"
    }, {
        "title": "Missing return statement in value returning function",
        "page": "28.21"
    }, {
        "title": "Division by zero",
        "page": "28.22"
    }, {
        "title": "Conversion between pointer types produces incorrectly aligned result",
        "page": "28.23"
    }, {
        "title": "Modifying the string returned by getenv, strerror, and setlocale functions",
        "page": "28.24"
    }]
}, {
    "TARGET_POINT": 28,
    "title": "Random Number Generation",
    "page": "29",
    "subs": [{
        "title": "Basic Random Number Generation",
        "page": "29.1"
    }, {
        "title": "Permuted Congruential Generator",
        "page": "29.2"
    }, {
        "title": "Xorshift Generation",
        "page": "29.3"
    }, {
        "title": "Restrict generation to a given range",
        "page": "29.4"
    }]
}, {
    "TARGET_POINT": 29,
    "title": "Preprocessor and Macros",
    "page": "30",
    "subs": [{
        "title": "Header Include Guards",
        "page": "30.1"
    }, {
        "title": "#if 0 to block out code sections",
        "page": "30.2"
    }, {
        "title": "Function-like macros",
        "page": "30.3"
    }, {
        "title": "Source ﬁle inclusion",
        "page": "30.4"
    }, {
        "title": "Conditional inclusion and conditional function signature modiﬁcation",
        "page": "30.5"
    }, {
        "title": "__cplusplus for using C externals in C++ code compiled with C++ - name mangling",
        "page": "30.6"
    }, {
        "title": "Token pasting",
        "page": "30.7"
    }, {
        "title": "Predeﬁned Macros",
        "page": "30.8"
    }, {
        "title": "Variadic arguments macro",
        "page": "30.9"
    }, {
        "title": "Macro Replacement",
        "page": "30.10"
    }, {
        "title": "Error directive",
        "page": "30.11"
    }, {
        "title": "FOREACH implementation",
        "page": "30.12"
    }]
}, {
    "TARGET_POINT": 30,
    "title": "Signal handling",
    "page": "31",
    "subs": [{
        "title": "Signal Handling with “signal()”",
        "page": "31.1"
    }]
}, {
    "TARGET_POINT": 31,
    "title": "Variable arguments",
    "page": "32",
    "subs": [{
        "title": "Using an explicit count argument to determine the length of the va_list",
        "page": "32.1"
    }, {
        "title": "Using terminator values to determine the end of va_list",
        "page": "32.2"
    }, {
        "title": "Implementing functions with a `printf()`-like interface",
        "page": "32.3"
    }, {
        "title": "Using a format string",
        "page": "32.4"
    }]
}, {
    "TARGET_POINT": 32,
    "title": "Assertion",
    "page": "33",
    "subs": [{
        "title": "Simple Assertion",
        "page": "33.1"
    }, {
        "title": "Static Assertion",
        "page": "33.2"
    }, {
        "title": "Assert Error Messages",
        "page": "33.3"
    }, {
        "title": "Assertion of Unreachable Code",
        "page": "33.4"
    }, {
        "title": "Precondition and Postcondition",
        "page": "33.5"
    }]
}, {
    "TARGET_POINT": 33,
    "title": "Generic selection",
    "page": "34",
    "subs": [{
        "title": "Check whether a variable is of a certain qualiﬁed type",
        "page": "34.1"
    }, {
        "title": "Generic selection based on multiple arguments",
        "page": "34.2"
    }, {
        "title": "Type-generic printing macro",
        "page": "34.3"
    }]
}, {
    "TARGET_POINT": 34,
    "title": "X-macros",
    "page": "35",
    "subs": [{
        "title": "Trivial use of X-macros for printfs",
        "page": "35.1"
    }, {
        "title": "Give the X macro as an argument",
        "page": "35.2"
    }, {
        "title": "Enum Value and Identiﬁer",
        "page": "35.3"
    }, {
        "title": "Code generation",
        "page": "35.4"
    }]
}, {
    "TARGET_POINT": 35,
    "title": "Aliasing and eective type",
    "page": "36",
    "subs": [{
        "title": "Eective type",
        "page": "36.1"
    }, {
        "title": "restrict qualiﬁcation",
        "page": "36.2"
    }, {
        "title": "Changing bytes",
        "page": "36.3"
    }, {
        "title": "Character types cannot be accessed through non-character types",
        "page": "36.4"
    }, {
        "title": "Violating the strict aliasing rules",
        "page": "36.5"
    }]
}, {
    "TARGET_POINT": 36,
    "title": "Compilation",
    "page": "37",
    "subs": [{
        "title": "The Compiler",
        "page": "37.1"
    }, {
        "title": "File Types",
        "page": "37.2"
    }, {
        "title": "The Linker",
        "page": "37.3"
    }, {
        "title": "The Preprocessor",
        "page": "37.4"
    }, {
        "title": "The Translation Phases",
        "page": "37.5"
    }]
}, {
    "TARGET_POINT": 37,
    "title": "Inline assembly",
    "page": "38",
    "subs": [{
        "title": "gcc Inline assembly in macros",
        "page": "38.1"
    }, {
        "title": "gcc Basic asm support",
        "page": "38.2"
    }, {
        "title": "gcc Extended asm support",
        "page": "38.3"
    }]
}, {
    "TARGET_POINT": 38,
    "title": "Identiﬁer Scope",
    "page": "39",
    "subs": [{
        "title": "Function Prototype Scope",
        "page": "39.1"
    }, {
        "title": "Block Scope",
        "page": "39.2"
    }, {
        "title": "File Scope",
        "page": "39.3"
    }, {
        "title": "Function scope",
        "page": "39.4"
    }]
}, {
    "TARGET_POINT": 39,
    "title": "Implicit and Explicit Conversions",
    "page": "40",
    "subs": [{
        "title": "Integer Conversions in Function Calls",
        "page": "40.1"
    }, {
        "title": "Pointer Conversions in Function Calls",
        "page": "40.2"
    }]
}, {
    "TARGET_POINT": 40,
    "title": "Type Qualiﬁers",
    "page": "41",
    "subs": [{
        "title": "Volatile variables",
        "page": "41.1"
    }, {
        "title": "Unmodiﬁable (const) variables",
        "page": "41.2"
    }]
}, {
    "TARGET_POINT": 41,
    "title": "Typedef",
    "page": "42",
    "subs": [{
        "title": "Typedef for Structures and Unions",
        "page": "42.1"
    }, {
        "title": "Typedef for Function Pointers",
        "page": "42.2"
    }, {
        "title": "Simple Uses of Typedef",
        "page": "42.3"
    }]
}, {
    "TARGET_POINT": 42,
    "title": "Storage Classes",
    "page": "43",
    "subs": [{
        "title": "auto",
        "page": "43.1"
    }, {
        "title": "register",
        "page": "43.2"
    }, {
        "title": "static",
        "page": "43.3"
    }, {
        "title": "typedef",
        "page": "43.4"
    }, {
        "title": "extern",
        "page": "43.5"
    }, {
        "title": "_Thread_local",
        "page": "43.6"
    }]
}, {
    "TARGET_POINT": 43,
    "title": "Declarations",
    "page": "44",
    "subs": [{
        "title": "Calling a function from another C ﬁle",
        "page": "44.1"
    }, {
        "title": "Using a Global Variable",
        "page": "44.2"
    }, {
        "title": "Introduction",
        "page": "44.3"
    }, {
        "title": "Typedef",
        "page": "44.4"
    }, {
        "title": "Using Global Constants",
        "page": "44.5"
    }, {
        "title": "Using the right-left or spiral rule to decipher C declaration",
        "page": "44.6"
    }]
}, {
    "TARGET_POINT": 44,
    "title": "Structure Padding and Packing",
    "page": "45",
    "subs": [{
        "title": "Packing structures",
        "page": "45.1"
    }, {
        "title": "Structure padding",
        "page": "45.2"
    }]
}, {
    "TARGET_POINT": 45,
    "title": "Memory management",
    "page": "46",
    "subs": [{
        "title": "Allocating Memory",
        "page": "46.1"
    }, {
        "title": "Freeing Memory",
        "page": "46.2"
    }, {
        "title": "Reallocating Memory",
        "page": "46.3"
    }, {
        "title": "realloc(ptr, 0) is not equivalent to free(ptr)",
        "page": "46.4"
    }, {
        "title": "Multidimensional arrays of variable size",
        "page": "46.5"
    }, {
        "title": "allocate memory on stack",
        "page": "46.6"
    }, {
        "title": "User-deﬁned memory management",
        "page": "46.7"
    }]
}, {
    "TARGET_POINT": 46,
    "title": "Implementation-deﬁned behaviour",
    "page": "47",
    "subs": [{
        "title": "Right shift of a negative integer",
        "page": "47.1"
    }, {
        "title": "Assigning an out-of-range value to an integer",
        "page": "47.2"
    }, {
        "title": "Allocating zero bytes",
        "page": "47.3"
    }, {
        "title": "Representation of signed integers",
        "page": "47.4"
    }]
}, {
    "TARGET_POINT": 47,
    "title": "Atomics",
    "page": "48",
    "subs": [{
        "title": "atomics and operators",
        "page": "48.1"
    }]
}, {
    "TARGET_POINT": 48,
    "title": "Jump Statements",
    "page": "49",
    "subs": [{
        "title": "Using return",
        "page": "49.1"
    }, {
        "title": "Using goto to jump out of nested loops",
        "page": "49.2"
    }, {
        "title": "Using break and continue",
        "page": "49.3"
    }]
}, {
    "TARGET_POINT": 49,
    "title": "Create and include header ﬁles",
    "page": "50",
    "subs": [{
        "title": "Introduction",
        "page": "50.1"
    }, {
        "title": "Self-containment",
        "page": "50.2"
    }, {
        "title": "Minimality",
        "page": "50.3"
    }, {
        "title": "Notation and Miscellany",
        "page": "50.4"
    }, {
        "title": "Idempotence",
        "page": "50.5"
    }, {
        "title": "Include What You Use (IWYU)",
        "page": "50.6"
    }]
}, {
    "TARGET_POINT": 50,
    "title": "Introduction",
    "page": "51",
    "subs": [{
        "title": "Introduction",
        "page": "51.1"
    }, {
        "title": "Classifying characters read from a stream",
        "page": "51.2"
    }, {
        "title": "Classifying characters from a string",
        "page": "51.3"
    }]
}, {
    "TARGET_POINT": 51,
    "title": "Side Eects",
    "page": "52",
    "subs": [{
        "title": "Pre/Post Increment/Decrement operators",
        "page": "52.1"
    }]
}, {
    "TARGET_POINT": 52,
    "title": "Multi-Character Character Sequence",
    "page": "53",
    "subs": [{
        "title": "Trigraphs",
        "page": "53.1"
    }, {
        "title": "Digraphs",
        "page": "53.2"
    }]
}, {
    "TARGET_POINT": 53,
    "title": "Constraints",
    "page": "54",
    "subs": [{
        "title": "Duplicate variable names in the same scope",
        "page": "54.1"
    }, {
        "title": "Unary arithmetic operators",
        "page": "54.2"
    }]
}, {
    "TARGET_POINT": 54,
    "title": "Inlining",
    "page": "55",
    "subs": [{
        "title": "Inlining functions used in more than one source ﬁle",
        "page": "55.1"
    }]
}, {
    "TARGET_POINT": 55,
    "title": "Unions",
    "page": "56",
    "subs": [{
        "title": "Using unions to reinterpret values",
        "page": "56.1"
    }, {
        "title": "Writing to one union member and reading from another",
        "page": "56.2"
    }, {
        "title": "Dierence between struct and union",
        "page": "56.3"
    }]
}, {
    "TARGET_POINT": 56,
    "title": "Threads (native)",
    "page": "57",
    "subs": [{
        "title": "Inititialization by one thread",
        "page": "57.1"
    }, {
        "title": "Start several threads",
        "page": "57.2"
    }]
}, {
    "TARGET_POINT": 57,
    "title": "Multithreading",
    "page": "58",
    "subs": [{
        "title": "C11 Threads simple example",
        "page": "58.1"
    }]
}, {
    "TARGET_POINT": 58,
    "title": "Interprocess Communication (IPC)",
    "page": "59",
    "subs": [{
        "title": "Semaphores",
        "page": "59.1"
    }]
}, {
    "TARGET_POINT": 59,
    "title": "Testing frameworks",
    "page": "60",
    "subs": [{
        "title": "Unity Test Framework",
        "page": "60.1"
    }, {
        "title": "CMocka",
        "page": "60.2"
    }, {
        "title": "CppUTest",
        "page": "60.3"
    }]
}, {
    "TARGET_POINT": 60,
    "title": "Valgrind",
    "page": "61",
    "subs": [{
        "title": "Bytes lost -- Forgetting to free",
        "page": "61.1"
    }, {
        "title": "Most common errors encountered while using Valgrind",
        "page": "61.2"
    }, {
        "title": "Running Valgrind",
        "page": "61.3"
    }, {
        "title": "Adding ﬂags",
        "page": "61.4"
    }]
}, {
    "TARGET_POINT": 61,
    "title": "Common C programming idioms and developer practices",
    "page": "62",
    "subs": [{
        "title": "Comparing literal and variable",
        "page": "62.1"
    }, {
        "title": "Do not leave the parameter list of a function blank — use void",
        "page": "62.2"
    }]
}, {
    "TARGET_POINT": 62,
    "title": "Common pitfalls",
    "page": "63",
    "subs": [{
        "title": "Mixing signed and unsigned integers in arithmetic operations",
        "page": "63.1"
    }, {
        "title": "Macros are simple string replacements",
        "page": "63.2"
    }, {
        "title": "Forgetting to copy the return value of realloc into a temporary",
        "page": "63.3"
    }, {
        "title": "Forgetting to allocate one extra byte for \\0",
        "page": "63.4"
    }, {
        "title": "Misunderstanding array decay",
        "page": "63.5"
    }, {
        "title": "Forgetting to free memory (memory leaks)",
        "page": "63.6"
    }, {
        "title": "Copying too much",
        "page": "63.7"
    }, {
        "title": "Mistakenly writing = instead of == when comparing",
        "page": "63.8"
    }, {
        "title": "Newline character is not consumed in typical scanf() call",
        "page": "63.9"
    }, {
        "title": "Adding a semicolon to a #deﬁne",
        "page": "63.10"
    }, {
        "title": "Incautious use of semicolons",
        "page": "63.11"
    }, {
        "title": "Undeﬁned reference errors when linking",
        "page": "63.12"
    }, {
        "title": "Checking logical expression against 'true'",
        "page": "63.13"
    }, {
        "title": "Doing extra scaling in pointer arithmetic",
        "page": "63.14"
    }, {
        "title": "Multi-line comments cannot be nested",
        "page": "63.15"
    }, {
        "title": "Ignoring return values of library functions",
        "page": "63.16"
    }, {
        "title": "Comparing ﬂoating point numbers",
        "page": "63.17"
    }, {
        "title": "Floating point literals are of type double by default",
        "page": "63.18"
    }, {
        "title": "Using character constants instead of string literals, and vice versa",
        "page": "63.19"
    }, {
        "title": "Recursive function — missing out the base condition",
        "page": "63.20"
    }, {
        "title": "Overstepping array boundaries",
        "page": "63.21"
    }, {
        "title": "Passing unadjacent arrays to functions expecting \"real\" multidimensional arrays",
        "page": "63.22"
    }]
}]


```
